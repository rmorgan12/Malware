from numpy import zeros, linspace
import numpy as np 
import matplotlib.pyplot as plt
import math 

def SLBQR():
    # Parameters 
    n_steps = 900
    dt = 1/30
    beta0 = .8
    mu = 0
    sigma = .9
    epsilon = .46
    delta = .6
    Lambda = .6
    tau = 5
    total_pop = 33
    # Inital Conditions
    S = zeros(n_steps+1)
    L = zeros(n_steps+1)
    B = zeros(n_steps+1)
    Q = zeros(n_steps+1)
    R = zeros(n_steps+1)
    t = np.zeros(n_steps+1)
    t[0] = 0.0
    S[0] = 30
    L[0] = 2
    B[0] = 1
    Q[0] = 0
    R[0] = 0
    # Simulation
    for i in range(n_steps):
        sdt = (-beta0*S[i]*(L[i] + B[i]) - mu*S[i] + mu*total_pop + epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) + Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30)))*dt
        ldt = (beta0*S[i]*(L[i] + B[i]) - mu*L[i] - sigma*L[i] - epsilon*L[i]) * dt
        bdt = (sigma*L[i] - delta*B[i] - mu*B[i]) * dt
        qdt = (delta*B[i] - mu*Q[i] - Lambda*Q[i]) * dt
        rdt = (epsilon*L[i] + Lambda*Q[i] - mu*R[i] - epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) - Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30))) * dt
        # Simulation
        S[i+1] = S[i] + sdt
        L[i+1] = L[i] + ldt
        B[i+1] = B[i] + bdt
        Q[i+1] = Q[i] + qdt
        R[i+1] = R[i] + rdt
        t[i+1] = t[i] + dt
    return S,L,B,Q,R,t

def MalSEIRS():
    n_steps = 900
    dt = 1/30
    beta0 = .8    
    F = 1        
    mu = 0       
    alpha = 0   
    c = 5         
    o = .9        
    Q = .46      
    P = 0        
    A = 0        
    a = .1        
    m = 1 
    total_pop = 33
    t = np.zeros(n_steps+1)
    S = zeros(len(t))
    E = zeros(len(t))
    I = zeros(len(t))
    R = zeros(len(t))
    N = zeros(len(t))
    #Initial conditions
    t[0] = 0.0
    S[0] = 30
    E[0] = 2
    I[0] = 1
    R[0] = 0
    N[0] = total_pop
    # Simulation
    for i in range(n_steps):
        BETA_FUNCTION = beta0/(1+F*I[i])                                 
        W_FUNCTION = abs(math.exp(-a*t[i]) * math.cos((2*math.pi*t[i])/m)) 
        Y_FUNCTION = math.tanh(I[i] / c)                                

        sdt = (P * A - (BETA_FUNCTION * I[i] * S[i]) + W_FUNCTION * R[i] - (mu + Q) * S[i]) * dt     
        edt = (BETA_FUNCTION * I[i] * S[i] - o * E[i] - mu * E[i]) * dt                           
        idt = (o * E[i] - Y_FUNCTION * I[i] - (mu + a) * I[i]) * dt                                 
        rdt = ((1 - P) * A + Y_FUNCTION * I[i] - W_FUNCTION * R[i] - mu * R[i] + Q * S[i]) * dt    

        S[i+1] = S[i] + sdt
        E[i+1] = E[i] + edt
        I[i+1] = I[i] + idt
        R[i+1] = R[i] + rdt
        t[i+1] = t[i] + dt
        N[i+1] = S[i] + E[i] + I[i] + R[i]
    return S,E,I,R,t

S,L,B,Q,R,t = SLBQR()
MS,ME,MI,MR,Mt = MalSEIRS()


plt.plot(t,S, label='S',color='b')
plt.plot(t,L, label='L',color='g')
plt.plot(t,B, label='B',color='orange')
plt.plot(t,R, label='R',color='purple')
plt.plot(t,MS, label='S proposed',color='b',linestyle='dashdot')
plt.plot(t,ME, label='E proposed',color='g',linestyle='dashdot')
plt.plot(t,MI, label='I proposed',color='orange',linestyle='dashdot')
plt.plot(t,MR, label='R proposed',color='purple',linestyle='dashdot')
plt.xlabel('Time')
plt.ylabel('Population')

plt.legend(ncol=2)

plt.show()

