from numpy import zeros, linspace
import numpy as np 
import matplotlib.pyplot as plt
import math 

def SLBQR():
    # Parameters 
    n_steps = 900
    dt = 1/30
    beta0 = .8
    mu = 0.3
    sigma = .9
    epsilon = .46
    delta = .6
    Lambda = .6
    tau = 5
    total_pop = 33
    # Inital Conditions
    S = zeros(n_steps+1)
    L = zeros(n_steps+1)
    B = zeros(n_steps+1)
    Q = zeros(n_steps+1)
    R = zeros(n_steps+1)
    t = np.zeros(n_steps+1)
    t[0] = 0.0
    S[0] = 30
    L[0] = 2
    B[0] = 1
    Q[0] = 0
    R[0] = 0
    # Simulation
    for i in range(n_steps):
        sdt = (-beta0*S[i]*(L[i] + B[i]) - mu*S[i] + mu*total_pop + epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) + Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30)))*dt
        ldt = (beta0*S[i]*(L[i] + B[i]) - mu*L[i] - sigma*L[i] - epsilon*L[i]) * dt
        bdt = (sigma*L[i] - delta*B[i] - mu*B[i]) * dt
        qdt = (delta*B[i] - mu*Q[i] - Lambda*Q[i]) * dt
        rdt = (epsilon*L[i] + Lambda*Q[i] - mu*R[i] - epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) - Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30))) * dt
        # Simulation
        S[i+1] = S[i] + sdt
        L[i+1] = L[i] + ldt
        B[i+1] = B[i] + bdt
        Q[i+1] = Q[i] + qdt
        R[i+1] = R[i] + rdt
        t[i+1] = t[i] + dt
    return S,L,B,Q,R,t

def StochasticSLBQR(white_noise):
    np.random.seed(8)
    # Parameters 
    n_steps = 900
    dt = 1/30
    beta0 = .8
    mu = 0.3
    sigma = .9
    epsilon = .46
    delta = .6
    Lambda = .6
    tau = 5
    total_pop = 33
    # Inital Conditions
    S = zeros(n_steps+1)
    L = zeros(n_steps+1)
    B = zeros(n_steps+1)
    Q = zeros(n_steps+1)
    R = zeros(n_steps+1)
    N = zeros(n_steps+1)
    t = np.zeros(n_steps+1)
    t[0] = 0.0
    N[0] = total_pop
    S[0] = 30
    L[0] = 2
    B[0] = 1
    Q[0] = 0
    R[0] = 0
    # Simulation
    for i in range(n_steps):
        sdt = (-beta0*S[i]*(L[i] + B[i]) - mu*S[i] + mu*total_pop + epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) + Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30)))*dt + white_noise*S[i]*np.sqrt(dt)*np.random.standard_normal()
        ldt = (beta0*S[i]*(L[i] + B[i]) - mu*L[i] - sigma*L[i] - epsilon*L[i]) * dt + white_noise*L[i]*np.sqrt(dt)*np.random.standard_normal()
        bdt = (sigma*L[i] - delta*B[i] - mu*B[i]) * dt + white_noise*B[i]*np.sqrt(dt)*np.random.standard_normal()
        qdt = (delta*B[i] - mu*Q[i] - Lambda*Q[i]) * dt + white_noise*Q[i]*np.sqrt(dt)*np.random.standard_normal()
        rdt = (epsilon*L[i] + Lambda*Q[i] - mu*R[i] - epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) - Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30))) * dt + white_noise*R[i]*np.sqrt(dt)*np.random.standard_normal()
        # Simulation
        S[i+1] = S[i] + sdt
        L[i+1] = L[i] + ldt
        B[i+1] = B[i] + bdt
        Q[i+1] = Q[i] + qdt
        R[i+1] = R[i] + rdt
        t[i+1] = t[i] + dt
    return S,L,B,Q,R,t

# white_noises = [0.00,.10,.20,.30]
# sSimulations = []
# lSimulations = []
# bSimulations = []
# qSimulations = []
# rSimulations = []
# tSimulation = None
# for white_noise in white_noises:
#     S, L, Q, B, R, t = StochasticSLBQR(white_noise)
#     tSimulation = t
#     sSimulations.append(S)
#     lSimulations.append(L)
#     bSimulations.append(B)
#     qSimulations.append(Q)
#     rSimulations.append(R)

# index = 0
# for sim in qSimulations:
#     plt.plot(tSimulation, sim, label=f'sigma= {white_noises[index]}')
#     index += 1

white_noise = .2
S, L, Q, B, R, t = SLBQR()
MS, ML, MQ, MB, MR, Mt = StochasticSLBQR(white_noise)
# plt.plot(t,S, label='S(t) Deterministic')
# plt.plot(t,L, label='L(t) Deterministic')
# plt.plot(t,B, label='B(t) Deterministic')
# plt.plot(t,Q, label='Q(t) Deterministic')
# plt.plot(t,R, label='R(t) Deterministic')
# plt.title('No Stochasticity')
plt.plot(t,MS, label='S(t) Stochastic')
plt.plot(t,ML, label='L(t) Stochastic')
plt.plot(t,MB, label='B(t) Stochastic')
plt.plot(t,MQ, label='Q(t) Stochastic')
plt.plot(t,MR, label='R(t) Stochastic')
plt.xlabel('Time Units')
plt.ylabel('Number of Nodes')
plt.legend()

plt.show()

