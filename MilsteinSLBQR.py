from numpy import zeros, linspace
import numpy as np 
import matplotlib.pyplot as plt
import math 

def SLBQR():
    # Parameters 
    n_steps = 900
    dt = 1/30
    beta0 = .8
    mu = 0.3
    sigma = .9
    epsilon = .46
    delta = .6
    Lambda = .6
    tau = 5
    total_pop = 33
    # Inital Conditions
    S = zeros(n_steps+1)
    L = zeros(n_steps+1)
    B = zeros(n_steps+1)
    Q = zeros(n_steps+1)
    R = zeros(n_steps+1)
    t = np.zeros(n_steps+1)
    t[0] = 0.0
    S[0] = 30
    L[0] = 2
    B[0] = 1
    Q[0] = 0
    R[0] = 0
    # Simulation
    for i in range(n_steps):
        sdt = (-beta0*S[i]*(L[i] + B[i]) - mu*S[i] + mu*total_pop + epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) + Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30)))*dt
        ldt = (beta0*S[i]*(L[i] + B[i]) - mu*L[i] - sigma*L[i] - epsilon*L[i]) * dt
        bdt = (sigma*L[i] - delta*B[i] - mu*B[i]) * dt
        qdt = (delta*B[i] - mu*Q[i] - Lambda*Q[i]) * dt
        rdt = (epsilon*L[i] + Lambda*Q[i] - mu*R[i] - epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) - Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30))) * dt
        # Simulation
        S[i+1] = S[i] + sdt
        L[i+1] = L[i] + ldt
        B[i+1] = B[i] + bdt
        Q[i+1] = Q[i] + qdt
        R[i+1] = R[i] + rdt
        t[i+1] = t[i] + dt
    return S,L,B,Q,R,t

def MilsteinStochasticSLBQR(white_noise):
    np.random.seed(8)
    # Parameters 
    n_steps = 900
    dt = 1/30
    beta0 = .8
    mu = 0.3
    sigma = .9
    epsilon = .46
    delta = .6
    Lambda = .6
    tau = 5
    total_pop = 33
    # Inital Conditions
    S = zeros(n_steps+1)
    L = zeros(n_steps+1)
    B = zeros(n_steps+1)
    Q = zeros(n_steps+1)
    R = zeros(n_steps+1)
    N = zeros(n_steps+1)
    t = np.zeros(n_steps+1)
    t[0] = 0.0
    N[0] = total_pop
    S[0] = 30
    L[0] = 2
    B[0] = 1
    Q[0] = 0
    R[0] = 0
    # Simulation
    for i in range(n_steps):
        norm1 = np.random.standard_normal()
        norm2 = np.random.standard_normal()
        norm3 = np.random.standard_normal()
        norm4 = np.random.standard_normal()
        norm5 = np.random.standard_normal()
        sdt = (-beta0*S[i]*(L[i] + B[i]) - mu*S[i] + mu*total_pop + epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) + Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30)))*dt + white_noise*S[i]*np.sqrt(dt)*norm1 + (white_noise/2)*S[i]*((norm1**2)-1)*dt
        ldt = (beta0*S[i]*(L[i] + B[i]) - mu*L[i] - sigma*L[i] - epsilon*L[i]) * dt + white_noise*L[i]*np.sqrt(dt)*norm2 + (white_noise/2)*L[i]*((norm2**2)-1)*dt
        bdt = (sigma*L[i] - delta*B[i] - mu*B[i]) * dt + white_noise*B[i]*np.sqrt(dt)*norm3 + (white_noise/2)*B[i]*((norm3**2)-1)*dt
        qdt = (delta*B[i] - mu*Q[i] - Lambda*Q[i]) * dt + white_noise*Q[i]*np.sqrt(dt)*norm4 + (white_noise/2)*Q[i]*((norm4**2)-1)*dt
        rdt = (epsilon*L[i] + Lambda*Q[i] - mu*R[i] - epsilon*L[i-(tau*30)]*math.exp(-mu*(tau*30)) - Lambda*Q[i-(tau*30)]*math.exp(-mu*(tau*30))) * dt + white_noise*R[i]*np.sqrt(dt)*norm5 + (white_noise/2)*R[i]*((norm5**2)-1)*dt
        # Simulation
        S[i+1] = S[i] + sdt
        L[i+1] = L[i] + ldt
        B[i+1] = B[i] + bdt
        Q[i+1] = Q[i] + qdt
        R[i+1] = R[i] + rdt
        t[i+1] = t[i] + dt
    return S,L,B,Q,R,t

white_noises = [0.00,.10,.20,.30]
sSimulations = []
lSimulations = []
bSimulations = []
qSimulations = []
rSimulations = []
tSimulation = None
for white_noise in white_noises:
    S, L, Q, B, R, t = MilsteinStochasticSLBQR(white_noise)
    tSimulation = t
    sSimulations.append(S)
    lSimulations.append(L)
    bSimulations.append(B)
    qSimulations.append(Q)
    rSimulations.append(R)
    print("test")

index = 0
for sim in rSimulations:
    plt.plot(tSimulation, sim, label=f'sigma= {white_noises[index]}')
    index += 1
    print("test2")

# white_noise = .2
# MS, ML, MQ, MB, MR, Mt = MilsteinStochasticSLBQR(white_noise)
# # plt.plot(t,S, label='S(t) Deterministic')
# # plt.plot(t,L, label='L(t) Deterministic')
# # plt.plot(t,B, label='B(t) Deterministic')
# # plt.plot(t,Q, label='Q(t) Deterministic')
# # plt.plot(t,R, label='R(t) Deterministic')
# # plt.title('No Stochasticity')
# plt.plot(Mt,MS, label='S(t) Milstein')
# plt.plot(Mt,ML, label='L(t) Milstein')
# plt.plot(Mt,MB, label='B(t) Milstein')
# plt.plot(Mt,MQ, label='Q(t) Milstein')
# plt.plot(Mt,MR, label='R(t) Milstein')
plt.xlabel('Time Units')
plt.ylabel('R(t)')
plt.legend()

plt.show()

